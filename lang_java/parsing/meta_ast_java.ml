(* generated by ocamltarzan with: camlp4o -o /tmp/yyy.ml -I pa/ pa_type_conv.cmo pa_vof.cmo  pr_o.cmo /tmp/xxx.ml  *)

open Ast_java

let rec vof_tok v = Meta_parse_info.vof_info_adjustable_precision v
and vof_wrap _of_a (v1, v2) =
  let v1 = _of_a v1 and v2 = vof_tok v2 in OCaml.VTuple [ v1; v2 ]
and vof_list1 _of_a = OCaml.vof_list _of_a

let vof_bracket of_a (_t1, x, _t2) =
  of_a x

let vof_ident v = vof_wrap OCaml.vof_string v

let vof_qualified_ident v = OCaml.vof_list vof_ident v

let rec vof_typ =
  function
  | TBasic v1 ->
      let v1 = vof_wrap OCaml.vof_string v1
      in OCaml.VSum (("TBasic", [ v1 ]))
  | TClass v1 ->
      let v1 = vof_class_type v1 in OCaml.VSum (("TClass", [ v1 ]))
  | TArray v1 -> let v1 = vof_typ v1 in OCaml.VSum (("TArray", [ v1 ]))
and vof_class_type v =
  vof_list1
    (fun (v1, v2) ->
       let v1 = vof_ident v1
       and v2 = OCaml.vof_list vof_type_argument v2
       in OCaml.VTuple [ v1; v2 ])
    v
and vof_type_argument =
  function
  | TArgument v1 ->
      let v1 = vof_ref_type v1 in OCaml.VSum (("TArgument", [ v1 ]))
  | TQuestion v1 ->
      let v1 =
        OCaml.vof_option
          (fun (v1, v2) ->
             let v1 = OCaml.vof_bool v1
             and v2 = vof_ref_type v2
             in OCaml.VTuple [ v1; v2 ])
          v1
      in OCaml.VSum (("TQuestion", [ v1 ]))
and vof_ref_type v = vof_typ v

let vof_type_parameter =
  function
  | TParam ((v1, v2)) ->
      let v1 = vof_ident v1
      and v2 = OCaml.vof_list vof_ref_type v2
      in OCaml.VSum (("TParam", [ v1; v2 ]))

let rec vof_modifier =
  function
  | Variadic -> OCaml.VSum (("Variadic", []))
  | Public -> OCaml.VSum (("Public", []))
  | Protected -> OCaml.VSum (("Protected", []))
  | Private -> OCaml.VSum (("Private", []))
  | Abstract -> OCaml.VSum (("Abstract", []))
  | Static -> OCaml.VSum (("Static", []))
  | Final -> OCaml.VSum (("Final", []))
  | StrictFP -> OCaml.VSum (("StrictFP", []))
  | Transient -> OCaml.VSum (("Transient", []))
  | Volatile -> OCaml.VSum (("Volatile", []))
  | Synchronized -> OCaml.VSum (("Synchronized", []))
  | Native -> OCaml.VSum (("Native", []))
  | Annotation v1 ->
      let v1 = vof_annotation v1 in OCaml.VSum (("Annotation", [ v1 ]))
and vof_annotation (v1, v2) =
  let v1 = vof_name_or_class_type v1
  and v2 = OCaml.vof_option vof_annotation_element v2
  in OCaml.VTuple [ v1; v2 ]
and vof_modifiers v = OCaml.vof_list (vof_wrap vof_modifier) v
and vof_annotation_element =
  function
  | AnnotArgValue v1 ->
      let v1 = vof_element_value v1 in OCaml.VSum (("AnnotArgValue", [ v1 ]))
  | AnnotArgPairInit v1 ->
      let v1 = OCaml.vof_list vof_annotation_pair v1
      in OCaml.VSum (("AnnotArgPairInit", [ v1 ]))
  | EmptyAnnotArg -> OCaml.VSum (("EmptyAnnotArg", []))
and vof_element_value =
  function
  | AnnotExprInit v1 ->
      let v1 = vof_expr v1 in OCaml.VSum (("AnnotExprInit", [ v1 ]))
  | AnnotNestedAnnot v1 ->
      let v1 = vof_annotation v1 in OCaml.VSum (("AnnotNestedAnnot", [ v1 ]))
  | AnnotArrayInit v1 ->
      let v1 = vof_list1 vof_element_value v1
      in OCaml.VSum (("AnnotArrayInit", [ v1 ]))
and vof_annotation_pair (v1, v2) =
  let v1 = vof_ident v1
  and v2 = vof_element_value v2
  in OCaml.VTuple [ v1; v2 ]
and vof_name_or_class_type v = OCaml.vof_list vof_identifier_ v
and vof_identifier_ =
  function
  | Id v1 -> let v1 = vof_ident v1 in OCaml.VSum (("Id", [ v1 ]))
  | Id_then_TypeArgs ((v1, v2)) ->
      let v1 = vof_ident v1
      and v2 = OCaml.vof_list vof_type_argument v2
      in OCaml.VSum (("Id_then_TypeArgs", [ v1; v2 ]))
  | TypeArgs_then_Id ((v1, v2)) ->
      let v1 = OCaml.vof_list vof_type_argument v1
      and v2 = vof_identifier_ v2
      in OCaml.VSum (("TypeArgs_then_Id", [ v1; v2 ]))
and vof_name v =
  vof_list1
    (fun (v1, v2) ->
       let v1 = OCaml.vof_list vof_type_argument v1
       and v2 = vof_ident v2
       in OCaml.VTuple [ v1; v2 ])
    v
and vof_literal =
  function
  | Bool v1 ->
      let v1 = vof_wrap OCaml.vof_bool v1 in OCaml.VSum (("Bool", [ v1 ]))
  | Int v1 ->
      let v1 = vof_wrap OCaml.vof_string v1 in OCaml.VSum (("Int", [ v1 ]))
  | Float v1 ->
      let v1 = vof_wrap OCaml.vof_string v1 in OCaml.VSum (("Float", [ v1 ]))
  | Char v1 ->
      let v1 = vof_wrap OCaml.vof_string v1 in OCaml.VSum (("Char", [ v1 ]))
  | String v1 ->
      let v1 = vof_wrap OCaml.vof_string v1
      in OCaml.VSum (("String", [ v1 ]))
  | Null v1 -> let v1 = vof_tok v1 in OCaml.VSum (("Null", [ v1 ]))


and vof_expr =
  function
  | Ellipsis v1 -> let v1 = vof_tok v1 in OCaml.VSum (("Ellipsis", [ v1 ]))
  | DeepEllipsis v1 -> let v1 = vof_bracket vof_expr v1 in 
      OCaml.VSum (("DeepEllipsis", [ v1 ]))
  | Name v1 -> let v1 = vof_name v1 in OCaml.VSum (("Name", [ v1 ]))
  | NameOrClassType v1 ->
      let v1 = vof_name_or_class_type v1
      in OCaml.VSum (("NameOrClassType", [ v1 ]))
  | Literal v1 ->
      let v1 = vof_literal v1
      in OCaml.VSum (("Literal", [ v1 ]))
  | ClassLiteral v1 ->
      let v1 = vof_typ v1 in OCaml.VSum (("ClassLiteral", [ v1 ]))
  | NewClass ((v0, v1, v2, v3)) ->
      let v0 = vof_tok v0 in
      let v1 = vof_typ v1
      and v2 = vof_arguments v2
      and v3 = OCaml.vof_option (vof_bracket vof_decls) v3
      in OCaml.VSum (("NewClass", [ v0; v1; v2; v3 ]))
  | NewArray ((v0, v1, v2, v3, v4)) ->
      let v0 = vof_tok v0 in
      let v1 = vof_typ v1
      and v2 = vof_arguments v2
      and v3 = OCaml.vof_int v3
      and v4 = OCaml.vof_option vof_init v4
      in OCaml.VSum (("NewArray", [ v0; v1; v2; v3; v4 ]))
  | NewQualifiedClass ((v0, v1, v2, v3, v4)) ->
      let v0 = vof_expr v0 in
      let v1 = vof_tok v1
      and v2 = vof_ident v2
      and v3 = vof_arguments v3
      and v4 = OCaml.vof_option (vof_bracket vof_decls) v4
      in OCaml.VSum (("NewQualifiedClass", [ v0; v1; v2; v3; v4 ]))
  | Call ((v1, v2)) ->
      let v1 = vof_expr v1
      and v2 = vof_arguments v2
      in OCaml.VSum (("Call", [ v1; v2 ]))
  | Dot ((v1, t, v2)) ->
      let v1 = vof_expr v1
      and t = vof_tok t
      and v2 = vof_ident v2
      in OCaml.VSum (("Dot", [ v1; t; v2 ]))
  | ArrayAccess ((v1, v2)) ->
      let v1 = vof_expr v1
      and v2 = vof_expr v2
      in OCaml.VSum (("ArrayAccess", [ v1; v2 ]))
  | Postfix ((v1, v2)) ->
      let v1 = vof_expr v1
      and v2 = vof_op v2
      in OCaml.VSum (("Postfix", [ v1; v2 ]))
  | Unary ((v1, v2)) ->
      let v1 = vof_wrap Meta_ast_generic_common.vof_arithmetic_operator v1
      and v2 = vof_expr v2
      in OCaml.VSum (("Unary", [ v1; v2 ]))
  | Prefix ((v1, v2)) ->
      let v1 = vof_op v1
      and v2 = vof_expr v2
      in OCaml.VSum (("Prefix", [ v1; v2 ]))
  | Infix ((v1, v2, v3)) ->
      let v1 = vof_expr v1
      and v2 = vof_wrap Meta_ast_generic_common.vof_arithmetic_operator v2
      and v3 = vof_expr v3
      in OCaml.VSum (("Infix", [ v1; v2; v3 ]))
  | Cast ((v1, v2)) ->
      let v1 = vof_typ v1
      and v2 = vof_expr v2
      in OCaml.VSum (("Cast", [ v1; v2 ]))
  | InstanceOf ((v1, v2)) ->
      let v1 = vof_expr v1
      and v2 = vof_ref_type v2
      in OCaml.VSum (("InstanceOf", [ v1; v2 ]))
  | Conditional ((v1, v2, v3)) ->
      let v1 = vof_expr v1
      and v2 = vof_expr v2
      and v3 = vof_expr v3
      in OCaml.VSum (("Conditional", [ v1; v2; v3 ]))
  | Assign ((v1, v2, v3)) ->
      let v1 = vof_expr v1
      and v2 = vof_tok v2
      and v3 = vof_expr v3
      in OCaml.VSum (("Assign", [ v1; v2; v3 ]))
  | AssignOp ((v1, v2, v3)) ->
      let v1 = vof_expr v1
      and v2 = vof_wrap Meta_ast_generic_common.vof_arithmetic_operator v2
      and v3 = vof_expr v3
      in OCaml.VSum (("AssignOp", [ v1; v2; v3 ]))
  | Lambda ((v1, v2)) ->
      let v1 = vof_parameters v1
      and v2 = vof_stmt v2
      in OCaml.VSum (("Lambda", [ v1; v2 ]))
and vof_arguments v = OCaml.vof_list vof_expr v
and vof_parameters x = OCaml.vof_list vof_parameter_binding x

and vof_parameter_binding =
  function
  | ParamClassic v1 ->
      let v1 = vof_parameter v1 in OCaml.VSum (("ParamClassic", [ v1 ]))
  | ParamEllipsis v1 ->
      let v1 = vof_tok v1 in OCaml.VSum (("ParamEllipsis", [ v1 ]))

and vof_parameter x = vof_var x

and vof_op v = vof_wrap Meta_ast_generic_common.vof_incr_decr v
and vof_stmt =
  function
  | Empty -> OCaml.VSum (("Empty", []))
  | Block v1 -> let v1 = vof_stmts v1 in OCaml.VSum (("Block", [ v1 ]))
  | Expr v1 -> let v1 = vof_expr v1 in OCaml.VSum (("Expr", [ v1 ]))
  | If ((t, v1, v2, v3)) ->
      let t = vof_tok t in
      let v1 = vof_expr v1
      and v2 = vof_stmt v2
      and v3 = OCaml.vof_option vof_stmt v3
      in OCaml.VSum (("If", [ t; v1; v2; v3 ]))
  | Switch ((v0, v1, v2)) ->
      let v0 = vof_tok v0 in
      let v1 = vof_expr v1
      and v2 =
        OCaml.vof_list
          (fun (v1, v2) ->
             let v1 = vof_cases v1
             and v2 = vof_stmts v2
             in OCaml.VTuple [ v1; v2 ])
          v2
      in OCaml.VSum (("Switch", [ v0; v1; v2 ]))
  | While ((t, v1, v2)) ->
      let t = vof_tok t in
      let v1 = vof_expr v1
      and v2 = vof_stmt v2
      in OCaml.VSum (("While", [ t; v1; v2 ]))
  | Do ((t, v1, v2)) ->
      let t = vof_tok t in
      let v1 = vof_stmt v1
      and v2 = vof_expr v2
      in OCaml.VSum (("Do", [ t; v1; v2 ]))
  | For ((t, v1, v2)) ->
      let t = vof_tok t in
      let v1 = vof_for_control v1
      and v2 = vof_stmt v2
      in OCaml.VSum (("For", [ t; v1; v2 ]))
  | Break (t, v1) ->
      let t = vof_tok t in
      let v1 = OCaml.vof_option vof_ident v1
      in OCaml.VSum (("Break", [ t; v1 ]))
  | Continue (t, v1) ->
      let t = vof_tok t in
      let v1 = OCaml.vof_option vof_ident v1
      in OCaml.VSum (("Continue", [ t; v1 ]))
  | Return (t, v1) ->
      let t = vof_tok t in
      let v1 = OCaml.vof_option vof_expr v1
      in OCaml.VSum (("Return", [ t; v1 ]))
  | Label ((v1, v2)) ->
      let v1 = vof_ident v1
      and v2 = vof_stmt v2
      in OCaml.VSum (("Label", [ v1; v2 ]))
  | Sync ((v1, v2)) ->
      let v1 = vof_expr v1
      and v2 = vof_stmt v2
      in OCaml.VSum (("Sync", [ v1; v2 ]))
  | Try ((t, v1, v2, v3)) ->
      let t = vof_tok t in
      let v1 = vof_stmt v1
      and v2 = vof_catches v2
      and v3 = OCaml.vof_option vof_tok_and_stmt v3
      in OCaml.VSum (("Try", [ t; v1; v2; v3 ]))
  | Throw (t, v1) -> 
      let t = vof_tok t in
      let v1 = vof_expr v1 in OCaml.VSum (("Throw", [ t; v1 ]))
  | LocalVar v1 ->
      let v1 = vof_var_with_init v1 in OCaml.VSum (("LocalVar", [ v1 ]))
  | LocalClass v1 ->
      let v1 = vof_class_decl v1 in OCaml.VSum (("LocalClass", [ v1 ]))
  | Assert ((t, v1, v2)) ->
      let t = vof_tok t in
      let v1 = vof_expr v1
      and v2 = OCaml.vof_option vof_expr v2
      in OCaml.VSum (("Assert", [ t; v1; v2 ]))

and vof_tok_and_stmt (t, v) = 
  let t = vof_tok t in
  let v = vof_stmt v in
  OCaml.VTuple [t; v]

and vof_stmts v = OCaml.vof_list vof_stmt v
and vof_case =
  function
  | Case (t, v1) -> 
      let t = vof_tok t in
      let v1 = vof_expr v1 in OCaml.VSum (("Case", [ t; v1 ]))
  | Default t -> 
      let t = vof_tok t in
      OCaml.VSum (("Default", [t]))
and vof_cases v = OCaml.vof_list vof_case v
and vof_for_control =
  function
  | ForClassic ((v1, v2, v3)) ->
      let v1 = vof_for_init v1
      and v2 = OCaml.vof_list vof_expr v2
      and v3 = OCaml.vof_list vof_expr v3
      in OCaml.VSum (("ForClassic", [ v1; v2; v3 ]))
  | Foreach ((v1, v2)) ->
      let v1 = vof_var v1
      and v2 = vof_expr v2
      in OCaml.VSum (("Foreach", [ v1; v2 ]))
and vof_for_init =
  function
  | ForInitVars v1 ->
      let v1 = OCaml.vof_list vof_var_with_init v1
      in OCaml.VSum (("ForInitVars", [ v1 ]))
  | ForInitExprs v1 ->
      let v1 = OCaml.vof_list vof_expr v1
      in OCaml.VSum (("ForInitExprs", [ v1 ]))
and vof_catch (t, v1, v2) =
  let t = vof_tok t in
  let v1 = vof_catch_var v1 and v2 = vof_stmt v2 in OCaml.VTuple [ t; v1; v2 ]
and vof_catches v = OCaml.vof_list vof_catch v

and vof_var { name = v_v_name; mods = v_v_mods; type_ = v_v_type } =
  let bnds = [] in
  let arg = OCaml.vof_option vof_typ v_v_type in
  let bnd = ("v_type", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_modifiers v_v_mods in
  let bnd = ("v_mods", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_ident v_v_name in
  let bnd = ("v_name", arg) in let bnds = bnd :: bnds 
  in OCaml.VDict bnds

and vof_catch_var (v1, v2) =
  let v1 = vof_var v1 in
  let v2 = OCaml.vof_list vof_typ v2 in
  OCaml.VTuple [v1; v2]

and vof_var_with_init { f_var = v_f_var; f_init = v_f_init } =
  let bnds = [] in
  let arg = OCaml.vof_option vof_init v_f_init in
  let bnd = ("f_init", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_var v_f_var in
  let bnd = ("f_var", arg) in let bnds = bnd :: bnds in OCaml.VDict bnds
and vof_init =
  function
  | ExprInit v1 -> let v1 = vof_expr v1 in OCaml.VSum (("ExprInit", [ v1 ]))
  | ArrayInit v1 ->
      let v1 = vof_bracket (OCaml.vof_list vof_init) v1
      in OCaml.VSum (("ArrayInit", [ v1 ]))
and
  vof_method_decl {
                    m_var = v_m_var;
                    m_formals = v_m_formals;
                    m_throws = v_m_throws;
                    m_body = v_m_body
                  } =
  let bnds = [] in
  let arg = vof_stmt v_m_body in
  let bnd = ("m_body", arg) in
  let bnds = bnd :: bnds in
  let arg = OCaml.vof_list vof_qualified_ident v_m_throws in
  let bnd = ("m_throws", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_parameters v_m_formals in
  let bnd = ("m_formals", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_var v_m_var in
  let bnd = ("m_var", arg) in let bnds = bnd :: bnds in OCaml.VDict bnds
and vof_field v = vof_var_with_init v
and
  vof_enum_decl {
                  en_name = v_en_name;
                  en_mods = v_en_mods;
                  en_impls = v_en_impls;
                  en_body = v_en_body
                } =
  let bnds = [] in
  let arg =
    match v_en_body with
    | (v1, v2) ->
        let v1 = OCaml.vof_list vof_enum_constant v1
        and v2 = vof_decls v2
        in OCaml.VTuple [ v1; v2 ] in
  let bnd = ("en_body", arg) in
  let bnds = bnd :: bnds in
  let arg = OCaml.vof_list vof_ref_type v_en_impls in
  let bnd = ("en_impls", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_modifiers v_en_mods in
  let bnd = ("en_mods", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_ident v_en_name in
  let bnd = ("en_name", arg) in let bnds = bnd :: bnds in OCaml.VDict bnds
and vof_enum_constant =
  function
  | EnumSimple v1 ->
      let v1 = vof_ident v1 in OCaml.VSum (("EnumSimple", [ v1 ]))
  | EnumConstructor ((v1, v2)) ->
      let v1 = vof_ident v1
      and v2 = vof_arguments v2
      in OCaml.VSum (("EnumConstructor", [ v1; v2 ]))
  | EnumWithMethods ((v1, v2)) ->
      let v1 = vof_ident v1
      and v2 = OCaml.vof_list vof_method_decl v2
      in OCaml.VSum (("EnumWithMethods", [ v1; v2 ]))
and
  vof_class_decl {
                   cl_name = v_cl_name;
                   cl_kind = v_cl_kind;
                   cl_tparams = v_cl_tparams;
                   cl_mods = v_cl_mods;
                   cl_extends = v_cl_extends;
                   cl_impls = v_cl_impls;
                   cl_body = v_cl_body
                 } =
  let bnds = [] in
  let arg = vof_bracket vof_decls v_cl_body in
  let bnd = ("cl_body", arg) in
  let bnds = bnd :: bnds in
  let arg = OCaml.vof_list vof_ref_type v_cl_impls in
  let bnd = ("cl_impls", arg) in
  let bnds = bnd :: bnds in
  let arg = OCaml.vof_option vof_typ v_cl_extends in
  let bnd = ("cl_extends", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_modifiers v_cl_mods in
  let bnd = ("cl_mods", arg) in
  let bnds = bnd :: bnds in
  let arg = OCaml.vof_list vof_type_parameter v_cl_tparams in
  let bnd = ("cl_tparams", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_class_kind v_cl_kind in
  let bnd = ("cl_kind", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_ident v_cl_name in
  let bnd = ("cl_name", arg) in let bnds = bnd :: bnds in OCaml.VDict bnds
and vof_class_kind =
  function
  | ClassRegular -> OCaml.VSum (("ClassRegular", []))
  | Interface -> OCaml.VSum (("Interface", []))
and vof_decl =
  function
  | Class v1 -> let v1 = vof_class_decl v1 in OCaml.VSum (("Class", [ v1 ]))
  | Method v1 ->
      let v1 = vof_method_decl v1 in OCaml.VSum (("Method", [ v1 ]))
  | Field v1 -> let v1 = vof_field v1 in OCaml.VSum (("Field", [ v1 ]))
  | Enum v1 -> let v1 = vof_enum_decl v1 in OCaml.VSum (("Enum", [ v1 ]))
  | Init ((v1, v2)) ->
      let v1 = OCaml.vof_bool v1
      and v2 = vof_stmt v2
      in OCaml.VSum (("Init", [ v1; v2 ]))
  | DeclEllipsis v1 -> let v1 = vof_tok v1 in OCaml.VSum (("DeclEllipsis", [ v1 ]))
and vof_decls v = (OCaml.vof_list vof_decl) v

and vof_import = function
  | ImportAll (t, v1, v2) ->
      let t = vof_tok t in
      let v1 = vof_qualified_ident v1 in
      let v2 = vof_tok v2 in
      OCaml.VSum ("ImportAll", [t; v1;v2])
  | ImportFrom (t, v1, v2) ->
      let t = vof_tok t in
      let v1 = vof_qualified_ident v1 in
      let v2 = vof_ident v2 in
      OCaml.VSum ("ImportFrom", [t; v1;v2])

let vof_package (v1, v2) =
  let v1 = vof_tok v1 in
  let v2 = vof_qualified_ident v2 in
  OCaml.VTuple [v1; v2]

let vof_compilation_unit {
                           package = v_package;
                           imports = v_imports;
                           decls = v_decls
                         } =
  let bnds = [] in
  let arg = vof_decls v_decls in
  let bnd = ("decls", arg) in
  let bnds = bnd :: bnds in
  let arg =
    OCaml.vof_list
      (fun (v1, v2) ->
         let v1 = OCaml.vof_bool v1
         and v2 = vof_import v2
         in OCaml.VTuple [ v1; v2 ])
      v_imports in
  let bnd = ("imports", arg) in
  let bnds = bnd :: bnds in
  let arg = OCaml.vof_option vof_package v_package in
  let bnd = ("package", arg) in let bnds = bnd :: bnds in OCaml.VDict bnds

let vof_directive_stmts v = OCaml.vof_list vof_import v

let vof_program v = vof_compilation_unit v

let vof_any =
  function
  | AIdent v1 -> let v1 = vof_ident v1 in OCaml.VSum (("AIdent", [ v1 ]))
  | AExpr v1 -> let v1 = vof_expr v1 in OCaml.VSum (("AExpr", [ v1 ]))
  | AStmt v1 -> let v1 = vof_stmt v1 in OCaml.VSum (("AStmt", [ v1 ]))
  | AStmts v1 -> let v1 = OCaml.vof_list vof_stmt v1 in 
      OCaml.VSum (("AStmt", [ v1 ]))
  | ADecls v1 -> let v1 = OCaml.vof_list vof_decl v1 in 
      OCaml.VSum (("ADecls", [ v1 ]))
  | ATyp v1 -> let v1 = vof_typ v1 in OCaml.VSum (("ATyp", [ v1 ]))
  | AVar v1 -> let v1 = vof_var v1 in OCaml.VSum (("AVar", [ v1 ]))
  | AInit v1 -> let v1 = vof_init v1 in OCaml.VSum (("AInit", [ v1 ]))
  | AMethod v1 ->
      let v1 = vof_method_decl v1 in OCaml.VSum (("AMethod", [ v1 ]))
  | AField v1 -> let v1 = vof_field v1 in OCaml.VSum (("AField", [ v1 ]))
  | AClass v1 ->
      let v1 = vof_class_decl v1 in OCaml.VSum (("AClass", [ v1 ]))
  | ADecl v1 -> let v1 = vof_decl v1 in OCaml.VSum (("ADecl", [ v1 ]))
  | ADirectiveStmt v1 -> let v1 = vof_import v1 in OCaml.VSum (("ADirectiveStmt", [ v1 ]))
  | ADirectiveStmts v1 -> let v1 = vof_directive_stmts v1 in OCaml.VSum (("ADirectiveStmts", [ v1 ]))
  | AProgram v1 ->
      let v1 = vof_program v1 in OCaml.VSum (("AProgram", [ v1 ]))
