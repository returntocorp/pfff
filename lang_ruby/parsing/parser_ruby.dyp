{
(* Mike Furr
 *
 * Copyright (C) 2010 Mike Furr
 * Copyright (C) 2020 r2c
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the <organization> nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Ast_ruby
module H = Ast_ruby_helpers
open Parser_ruby_helpers

(*let () = Dyp.dypgen_verbose := max_int*)

let dyp_merge_Obj_eols                   = merge_rest "eols"
let dyp_merge_Obj_some_eols              = merge_rest "some_eols "
let dyp_merge_Obj_main                   = merge_rest "main"
let dyp_merge_Obj_stmt_list              = merge_expr_list "stmt_list"
let dyp_merge_Obj_stmt                   = merge_stmt (*merge_expr "stmt"*)
let dyp_merge_Obj_topcall                = merge_topcall
let dyp_merge_Obj_arg_comma_list_trail   = merge_rest "arg_comma_list_trail"
let dyp_merge_Obj_arg_comma_nonempty_list= merge_rest "arg_comma_nonempty_list"
let dyp_merge_Obj_arg_comma_star_list    = merge_rest "arg_comma_star_list"
let dyp_merge_Obj_func                   = merge_expr "func"
let dyp_merge_Obj_star_amper             = merge_rest "star_amper"
let dyp_merge_Obj_call_args              = merge_expr_list "call_args"
let dyp_merge_Obj_command                = merge_expr "command"
let dyp_merge_Obj_command_name           = merge_expr "command_name"
let dyp_merge_Obj_binop                  = merge_binop
let dyp_merge_Obj_arg                    = merge_binop (*arg "arg"*)
let dyp_merge_Obj_expr                   = merge_expr "expr"
let dyp_merge_Obj_primary                = merge_expr "primary"
let dyp_merge_Obj_array_item             = merge_rest "array_item"
let dyp_merge_Obj_array_body_rest        = merge_rest "array_body_rest"
let dyp_merge_Obj_array_body             = merge_expr_list "array_body"
let dyp_merge_Obj_scoped_id              = merge_rest "scoped_id"
let dyp_merge_Obj_class_inheritance      = merge_rest "class_inheritance"
let dyp_merge_Obj_do_sep                 = merge_rest "do_sep"
let dyp_merge_Obj_code_block             = merge_rest "code_block"
let dyp_merge_Obj_code_block_body        = merge_rest "code_block_body"
let dyp_merge_Obj_formal_arg             = merge_rest "formal_arg"
let dyp_merge_Obj_formal_arg_nonempty_list= merge_formal_list "formal_arg_nonempty_list"
let dyp_merge_Obj_formal_arg_list   = merge_formal_list "formal_arg_list"
let dyp_merge_Obj_method_formals    = merge_formal_list "method_formals"
let dyp_merge_Obj_lhs               = merge_rest "lhs"
let dyp_merge_Obj_mlhs              = merge_rest "mlhs"
let dyp_merge_Obj_mlhs_clean        = merge_expr_list "mlhs_clean"
let dyp_merge_Obj_mlhs_rest         = merge_rest "mlhs_rest"
let dyp_merge_Obj_mlhs_item         = merge_rest "mlhs_item"
let dyp_merge_Obj_command_codeblock = merge_rest "command_codeblock"
let dyp_merge_Obj_mrhs              = merge_expr_list "mrhs"
let dyp_merge_Obj_then_sep          = merge_rest "then_sep"
let dyp_merge_Obj_when_clauses      = merge_rest "when_clauses"
let dyp_merge_Obj_body_exn          = merge_rest "body_exn"
let dyp_merge_Obj_rescue_clause     = merge_rescue "rescue_clause"
let dyp_merge_Obj_rescue_list       = merge_rest "rescue_list"
let dyp_merge_Obj_case_else         = merge_rest "case_else"
let dyp_merge_Obj_ensure_clause     = merge_rest "ensure_clause"
let dyp_merge_Obj_if_else_clauses   = merge_rest "if_else_clauses"
let dyp_merge_Obj_meth_or_atom      = merge_rest "meth_or_atom"
let dyp_merge_Obj_method_name       = merge_expr "method_name"
let dyp_merge_Obj_assignable        = merge_rest "assignable"
let dyp_merge_Obj_message_identifier= merge_rest "message_identifier"
let dyp_merge_Obj_bin_op            = merge_rest "bin_op"
let dyp_merge_Obj_unary_op          = merge_rest "unary_op"
let dyp_merge_Obj_keyword_as_id     = merge_rest "keyword_as_id"
let dyp_merge_Obj_identifier        = merge_rest "identifier"
let dyp_merge_Obj_constant          = merge_rest "constant"

let dyp_merge xs =
  wrap xs (fun xs ->
  Printf.eprintf "<all> branches: %d\n%!" (List.length xs);
  xs
  )
  (*Dyp.keep_all*)
}

/*(*************************************************************************)*/
/*(*1 Tokens *)*/
/*(*************************************************************************)*/

/*(*-----------------------------------------*)*/
/*(*2 The space/comment tokens *)*/
/*(*-----------------------------------------*)*/

/*(*-----------------------------------------*)*/
/*(*2 The normal tokens *)*/
/*(*-----------------------------------------*)*/

/*(*-----------------------------------------*)*/
/*(*2 Keyword tokens *)*/
/*(*-----------------------------------------*)*/

/*(*-----------------------------------------*)*/
/*(*2 Punctuation tokens *)*/
/*(*-----------------------------------------*)*/

/*(* syntax *)*/

/*(* operators *)*/


/*(*-----------------------------------------*)*/
/*(*2 Extra tokens: *)*/
/*(*-----------------------------------------*)*/

%token <Lexing.position> T_DOT          /* . */
%token <Lexing.position> T_COMMA        /* , */
%token <Lexing.position> T_PLUS     /* + */
%token <Lexing.position> T_UPLUS    /* unary + */
%token <Lexing.position> T_MINUS    /* - */
%token <Lexing.position> T_UMINUS   /* unary - */
%token <Lexing.position> T_POW      /* ** */
%token <Lexing.position> T_CMP      /* <=> */
%token <Lexing.position> T_ASSIGN       /* = */
%token <Lexing.position> T_EQ       /* == */
%token <Lexing.position> T_EQQ      /* === */
%token <Lexing.position> T_NEQ      /* != */
%token <Lexing.position> T_GEQ      /* >= */
%token <Lexing.position> T_LEQ      /* <= */
%token <Lexing.position> T_LT       /* < */
%token <Lexing.position> T_GT       /* > */
%token <Lexing.position> T_ANDOP 
       <Lexing.position> T_OROP         /* && and || */
%token <Lexing.position> T_MATCH
        <Lexing.position> T_NMATCH  /* =~ and !~ */
%token <Lexing.position> T_DOT2
       <Lexing.position> T_DOT3 /* .. and ... */
%token <Lexing.position> T_LSHFT
       <Lexing.position> T_RSHFT    /* << and >> */
%token <string*Lexing.position> T_OP_ASGN   /* +=, -=  etc. */
%token <Lexing.position> T_ASSOC    /* => */
%token <Lexing.position> T_LPAREN   /* _( */
%token <Lexing.position> T_LPAREN_ARG   /* ( */
%token <Lexing.position> T_RPAREN   /* ) */
%token <Lexing.position> T_LBRACK_ARG   /* [ as in x[y] = 2 */
%token <Lexing.position> T_LBRACK   /* [ as in x [y] aka x([y]) */
%token <Lexing.position> T_RBRACK   /* ] */
%token <Lexing.position> T_LBRACE   /* { for hash */
%token <Lexing.position> T_LBRACE_ARG   /* { for code block */
%token <Lexing.position> T_RBRACE   /* } */
%token <Lexing.position> T_STAR     /* * */
%token <Lexing.position> T_USTAR    /* * */
%token <Lexing.position> T_SLASH    /* / */
%token <Lexing.position> T_PERCENT  /* % */
%token <Lexing.position> T_QUESTION     /* ? */
%token <Lexing.position> T_COLON        /* : */
%token <Lexing.position> T_CARROT       /* ^ */
%token <Lexing.position> T_VBAR         /* | */
%token <Lexing.position> T_BANG         /* ! */
%token <Lexing.position> T_TILDE        /* ~ */
%token <Lexing.position> T_AMPER    /* & */
%token <Lexing.position> T_UAMPER   /* & */
%token <Lexing.position> T_SEMICOLON    /* ; */
%token <Lexing.position> T_SCOPE        /* x::y */
%token <Lexing.position> T_USCOPE       /* f ::y */

%token <string * Lexing.position> T_UID
%token <string * Lexing.position> T_LID
%token <string * Lexing.position> T_GLOBAL_VAR
%token <string * Lexing.position> T_INST_VAR
%token <string * Lexing.position> T_CLASS_VAR
%token <Ast_ruby.interp_string * Lexing.position> T_ATOM
%token <int * Lexing.position> T_FIXNUM
%token <Big_int.big_int * Lexing.position> T_BIGNUM
%token <string * float * Lexing.position> T_FLOAT
%token <string * Lexing.position> T_BUILTIN_VAR

/* keywords */
%token <string*Lexing.position>  K_CLASS
       <string*Lexing.position> K_MODULE
       <string*Lexing.position> K_DEF
       <Lexing.position> K_END
       <Lexing.position> K_ALIAS
       <Lexing.position> K_UNDEF
       <Lexing.position> K_BEGIN
       <Lexing.position> K_RESCUE
       <Lexing.position> K_ENSURE
       <Lexing.position> K_IF
       <Lexing.position> K_UNLESS
       <Lexing.position> K_THEN
       <Lexing.position> K_ELSIF
       <Lexing.position> K_ELSE
       <Lexing.position> K_CASE
       <Lexing.position> K_WHEN
       <Lexing.position> K_WHILE
       <Lexing.position> K_UNTIL
       <Lexing.position> K_FOR
       <Lexing.position> K_IN
       <Lexing.position> K_DO
       <Lexing.position> K_RETURN
       <Lexing.position> K_AND
       <Lexing.position> K_OR
       <Lexing.position> K_NOT
       <Lexing.position> K_lBEGIN
       <Lexing.position> K_lEND
       <Lexing.position> K_NIL
       <Lexing.position> K_YIELD
       <Lexing.position> K_SELF
       <Lexing.position> K_TRUE
       <Lexing.position> K_FALSE
/*
    K_DEFINED
    K_SUPER
    K_BREAK
    K_REDO
    K_RETRY
    K_NEXT*/
     /* K___LIN_
    K___FIL_
      */

%token <string * Lexing.position> T_SINGLE_STRING
%token <Ast_ruby.interp_string * Lexing.position> T_DOUBLE_STRING
%token <string * Ast_ruby.interp_string * Lexing.position> T_USER_STRING
%token <Lexing.position> T_DOUBLE_BEG
%token <Lexing.position> T_TICK_BEG
%token <string * Lexing.position> T_USER_BEG
%token <Lexing.position> T_REGEXP_BEG
%token <string> T_REGEXP_MOD
%token <Ast_ruby.interp_string * string * Lexing.position> T_REGEXP
%token <Lexing.position> T_ATOM_BEG
%token <string * Lexing.position> T_INTERP_STR
%token <string * Lexing.position> T_INTERP_END

%token T_EOL
%token T_EOF

/*(*************************************************************************)*/
/*(*1 Rules type declaration *)*/
/*(*************************************************************************)*/

%start <Ast_ruby.ast> main

%%

/*(*************************************************************************)*/
/*(*1 Toplevel *)*/
/*(*************************************************************************)*/

main: eols stmt_list<program> T_EOF { program }

eols:
  | /*empty*/  {}
  | eols T_EOL {}

stmt_list:
  | /*empty*/ { [] }
  | stmt<s>   { [s] }
  | T_SEMICOLON         eols stmt_list<ss> @{ ss,     [Dyp.Dont_shift] }
  | stmt<s> eol_or_semi eols stmt_list<ss> @{ s:: ss, [Dyp.Dont_shift] }

/*(*************************************************************************)*/
/*(*1 Function definition *)*/
/*(*************************************************************************)*/

/*(*----------------------------*)*/
/*(*2 parameters *)*/
/*(*----------------------------*)*/

/*(*************************************************************************)*/
/*(*1 Class definition *)*/
/*(*************************************************************************)*/

assign_op: 
  | T_ASSIGN {Op_ASSIGN}
  | T_OP_ASGN<op,pos> { Op_OP_ASGN (H.binary_op_of_string op) }

/* tokens that need to reduce immediately to guide the lexer */
scope_begin:  K_BEGIN<pos> {enter_scope dyp;pos}
scope_end:    K_END<pos>   {enter_scope dyp;pos}
scope_def:    K_DEF<pos>   {enter_scope dyp;pos}
scope_class:  K_CLASS<t_info,pos>  {enter_scope dyp;t_info,pos}
scope_module: K_MODULE<t_info,pos> {enter_scope dyp;t_info,pos}
seen_id: identifier<i> {seen dyp i;i}

/*(*************************************************************************)*/
/*(*1 Statement *)*/
/*(*************************************************************************)*/

stmt:
  | K_ALIAS<pos> meth_or_atom<e1> meth_or_atom<e2> 
      { D (Alias(e1,e2,pos)) }
  | K_UNDEF<pos> meth_or_atom_list<e1> 
      { D (Undef(e1,pos)) }
  | stmt<s> K_IF<pos>     eols stmt<guard> 
      { if is_cond_modifier guard then raise Dyp.Giveup; 
        S (If(guard, [s], [],pos)) }
  | stmt<s> K_UNLESS<pos> eols stmt<guard>
      { if is_cond_modifier guard then raise Dyp.Giveup; 
        S (Unless(guard, [s], [],pos)) }
  | stmt<s> K_UNTIL<pos>  eols stmt<guard> 
      { if is_cond_modifier guard then raise Dyp.Giveup; 
        S (Until(is_exnblock s,guard, [s],pos)) }
  | stmt<s> K_WHILE<pos>  eols stmt<guard>
      { if is_cond_modifier guard then raise Dyp.Giveup;
        S (While(is_exnblock s,guard, [s],pos)) }
  | stmt<s> K_RESCUE<pos> eols stmt<guard>
      { if is_cond_modifier guard then raise Dyp.Giveup;
        S (ExnBlock({body_exprs = [s]; rescue_exprs = [(S Empty,guard)];
            ensure_expr = []; else_expr = []}, pos)) }

      /* handle special case for x = y rescue z where rescue binds to 
    just the rhs, not the full assignment (unlike the other modifiers)
      */
  | lhs_assign_op<l,op> eols arg<r> K_RESCUE<pos> eols stmt<guard>
      { if is_cond_modifier guard then raise Dyp.Giveup;
        let r' = S (ExnBlock({body_exprs = [r]; rescue_exprs = [(S Empty,guard)];
                 ensure_expr = []; else_expr = []}, pos))
    in (*prune_binop l op r'*) 
         Binop(l,op,r',pos)}

  | scope_begin<pos> eols T_LBRACE eols stmt_list<body> T_RBRACE
      { leave_scope dyp; D (BeginBlock(body,pos))}
  | scope_end<pos> eols T_LBRACE eols stmt_list<body> T_RBRACE
      { leave_scope dyp; D (EndBlock(body,pos))}

  | topcall<c> 
      { c }
  | mlhs_assign_op<l,op> eols mrhs<r>
      { (*prune_binop (tuple l) op (tuple r)*) 
    let lhs = tuple l in
         Binop(lhs,op,(tuple r),(H.pos_of lhs))
      }
  | expr<e> 
      { e }
  | T_USTAR<pos> primary<e> 
      { Unary(Op_UStar,e,pos) }

lhs_assign_op: lhs<l> assign_op<op>   {seen dyp l; l,op}
mlhs_assign_op: mlhs<l> assign_op<op> {List.iter (seen dyp) l; l,op}

topcall:
  | func<f> { f }
  | func<c> code_block<cb>
      { match c with
    | Call(m,args,None,pos) -> methodcall m args (Some cb) pos
    | _ -> methodcall c [] (Some cb) (H.pos_of c)}

  | command<c> {c}
  | command_name<m> call_args<args> do_codeblock<cb>
      { well_formed_command m args;
    methodcall m args (Some cb) (H.pos_of m)}

arg_comma_list_trail:
  | arg_comma_star_list<e> {e}
  | arg_comma_star_list<e> T_COMMA {e}

arg_comma_nonempty_list:
  | arg<a> { [a] }
  | arg<a> T_COMMA eols arg_comma_nonempty_list<al> 
      @{ a::al, [Dyp.Dont_shift] }

arg_comma_star_list:
  | /*empty*/     { [] }
  | star_amper<a> { a }
  | arg_comma_nonempty_list<args> {args}
  | arg_comma_nonempty_list<args> T_COMMA eols star_amper<a>
      @{ args @ a, [Dyp.Dont_shift] }

func:
  | command_name<c> lparen eols call_args<args> eols T_RPAREN
      { match args with
        | [] -> Call(c,args,None,H.pos_of c) 
        | _ -> methodcall c args None (H.pos_of c)
      }
  | command_name<c> lparen eols command<a> eols T_RPAREN
      { Call(c,[a],None,H.pos_of c)}

star_amper:
  | T_USTAR<pos> arg<a> 
      { [Unary(Op_UStar,a,pos)] }
  | T_UAMPER<pos> arg<a> 
      { [Unary(Op_UAmper,a,pos)] }
  | T_USTAR<pos1> arg<a1> T_COMMA eols T_UAMPER<pos2> arg<a2>
      { [Unary(Op_UStar,a1,pos1); Unary(Op_UAmper,a2,pos2)] }

call_args:
  | /*empty*/ { [] }
  | arg_comma_star_list<args> { args }
  | T_LBRACK<pos> eols call_args<args> eols T_RBRACK { [Array(args,pos)] }

command:
  | K_YIELD<pos> call_args<args> 
      { well_formed_return args;
    S (Yield(args,pos)) }
  | command_name<m> call_args<args>
      { well_formed_command m args;
    methodcall m args None (H.pos_of m)}
  | command_name<cmd> command<cmd2>
    {well_formed_command cmd [cmd2];
     methodcall cmd [cmd2] None (H.pos_of cmd)}

command_name:
  | identifier<id> {id}
  | primary<p> T_DOT eols message_identifier<m>
      { unfold_dot p m (H.pos_of p)}
  | command_name<p> T_DOT eols message_identifier<m>
      { unfold_dot p m (H.pos_of p)}
  | primary<p> T_SCOPE message_identifier<m> 
      { scope p m }
  | command_name<p> T_SCOPE message_identifier<m>
      { scope p m }

lhs_prune_binop: lhs<l> {match l with Binop _ -> raise Dyp.Giveup | _ -> l}
lhs_pruned_assign_op: lhs_prune_binop<l> assign_op<op> {seen dyp l; l,op}

arg:
  | primary<p> {p}
  | unary_op<o,pos> eols arg<a> { prune_uop o a pos }
  | lhs_pruned_assign_op<l,op> eols arg<r> 
      { prune_right_assoc l op r }

  | arg<l> bin_op<bop> eols arg<r>{ prune_left_assoc l bop r }
  | arg<l> T_ANDOP eols arg<r> { prune_left_assoc l Op_AND r }
  | arg<l> T_OROP eols arg<r>  { prune_left_assoc l Op_OR r }
  | arg<e1> T_QUESTION<pos> eols expr<e2> T_COLON eols expr<e3>   
    { prune_tern e1 e2 e3 (H.pos_of e1) }

/*(*************************************************************************)*/
/*(*1 Expressions *)*/
/*(*************************************************************************)*/

/*(*----------------------------*)*/
/*(*2 strings *)*/
/*(*----------------------------*)*/


/*(*----------------------------*)*/
/*(*2 containers *)*/
/*(*----------------------------*)*/

/*(*----------------------------*)*/
/*(*2 Arguments *)*/
/*(*----------------------------*)*/

expr:
  | K_RETURN<pos> call_args<args>
      { well_formed_return args; 
        S (Return(args,pos)) }
  | K_RETURN<pos> arg<p>
      { match p with
        | S Block([x],_) -> S (Return([x],pos))
        | arg -> if is_cond_modifier arg then raise Dyp.Giveup;
        S (Return([arg],pos)) }

  | K_YIELD<pos> call_args<args> 
      { well_formed_return args;
        S (Yield(args,pos)) }
  | expr<e1> K_AND eols expr<e2> { prune_left_assoc e1 Op_kAND e2 }
  | expr<e1> K_OR eols expr<e2>  { prune_left_assoc e1 Op_kOR e2 }
  | K_NOT<pos>  eols expr<e>     { prune_uop Op_UNot e pos}
  | T_BANG<pos> eols expr<e>     { prune_uop Op_UBang e pos}
  | command<c>              {c}
  | arg<a>                  { a }

primary:
  | T_LPAREN<pos> eols stmt_list<ss> T_RPAREN
      { (* don't collapse the block here to prevent the disambiguation
      rules from erroneously firing *) 
         S (Block(ss,pos)) }
  | constant<c> { c }
  | identifier<id> { id }
  | command_name<c> { methodcall c [] None (H.pos_of c)}
  | command_name<c> code_block<cb> { command_codeblock c cb }
  | primary<p> T_SCOPE identifier<id> { scope p id }
  | T_USCOPE<pos> identifier<id> { Unary(Op_UScope,id,pos) }
  | primary<p> T_LBRACK_ARG<pos1> eols arg_comma_list_trail<args> eols T_RBRACK
      { methodcall (Binop(p,Op_DOT,Operator(Op_AREF,pos1),H.pos_of p)) args None (H.pos_of p)}

  | T_LBRACK<pos> eols array_body<body> eols T_RBRACK { Array(body,pos) }
  | T_LBRACE<pos> eols array_body<body> eols T_RBRACE { Hash(true,body,pos) }
  | K_RETURN<pos> { S (Return([],pos)) }
/*  | K_RETURN<pos> T_LPAREN eols call_args<args> eols T_RPAREN { Return(args,pos)}
  | K_RETURN<pos> lparen eols expr<arg> eols T_RPAREN { S (Return([arg],pos))}*/
  | K_YIELD<pos> { S (Yield([],pos)) }
  | K_YIELD<pos> lparen eols call_args<args> eols T_RPAREN { S (Yield(args,pos))}
  | K_YIELD<pos> lparen eols expr<arg> eols T_RPAREN { S (Yield([arg],pos))}

  | func<f> { f }
  | func<f> code_block<cb> {match f with
      | Call(m,args,None,pos) -> methodcall m args (Some cb) pos
      | _ -> methodcall f [] (Some cb) (H.pos_of f)}

  | K_IF<pos> expr<guard> then_sep stmt_list<body> if_else_clauses<else_e> K_lEND
    { S (If(guard,body,else_e,pos)) }

  | K_UNLESS<pos> expr<guard> then_sep stmt_list<body> case_else<else_e> K_lEND
    { S (Unless(guard,body, else_e,pos)) }

  | K_WHILE<pos> expr<guard> do_sep stmt_list<body> K_lEND
    { well_formed_do guard body; 
      S (While(false,guard,body,pos)) }

  | K_UNTIL<pos> expr<guard> do_sep stmt_list<body> K_lEND
    { well_formed_do guard body;
      S (Until(false,guard,body,pos)) }

  | K_CASE<pos> some_eols when_clauses<whens> case_else<else_e> K_lEND
    { S (Case({case_guard = S Empty; case_whens = whens; case_else = else_e},pos)) }

  | K_CASE<pos> eols expr<e> eols when_clauses<whens> case_else<else_e> K_lEND
    { S (Case({case_guard = e; case_whens = whens; case_else = else_e},pos)) }

  | K_CASE<pos> eols expr<e> T_SEMICOLON eols when_clauses<whens> case_else<else_e> K_lEND

    { S (Case({case_guard = e; case_whens = whens; case_else = else_e},pos)) }

  | K_FOR<pos> formal_arg_list<vars> K_IN arg<range> do_sep stmt_list<body> K_lEND
    { well_formed_do range body; 
      S (For(vars,range,body,pos)) }

  | K_lBEGIN<pos> eols body_exn<body>  K_lEND { S (ExnBlock(body,pos)) }

  | scope_class<t_info,pos> eols scoped_id<class_name> class_inheritance<inh> do_sep
      body_exn<body> K_lEND
      { leave_scope dyp;
        D (ClassDef(class_name, inh, body, pos))}

  | scope_class<t_info,pos> T_LSHFT arg<id> eols body_exn<body> K_lEND
      { leave_scope dyp;
        D (ClassDef(S Empty, Some (Inst_Inherit id), body, pos)) }

  | scope_module<t_info,pos> scoped_id<name> eols body_exn<body> K_lEND 
      { leave_scope dyp;
        D (ModuleDef (name,body, pos)) }

  | scope_def<t_info,pos> method_name<meth_name> method_formals<formals> eols
      body_exn<body> K_lEND
      { leave_scope dyp;
        D (MethodDef (meth_name, formals, body, pos)) }

array_item: 
  | arg<e> { e }
  | constant<c> T_LBRACK<pos1> eols call_args<args> eols T_RBRACK
      {methodcall
     (Binop(c, Op_DOT, Operator(Op_AREF,pos1), H.pos_of c)) 
     args None (H.pos_of c)
      }

array_body_rest:
  | { [] }
  | array_item<e> { [e] }
  | star_amper<es> { es }
  | array_item<e> T_COMMA eols array_body_rest<es> 
      @{ e::es, [Dyp.Dont_shift] }

array_body:
  | command<c> { [c] }
  | array_body_rest<es> { es }

scoped_id:
  | identifier<id> { id }
  | T_USCOPE<pos> identifier<id> { Unary(Op_UScope,id,pos)}
  | scoped_id<id1> T_SCOPE identifier<id2>    { Binop(id1,Op_SCOPE,id2,H.pos_of id1) }
  | scoped_id<id1> T_SCOPE keyword_as_id<id2> { Binop(id1,Op_SCOPE,id2,H.pos_of id1) }

class_inheritance:
 | {None}
 | T_LT primary<p> { Some (Class_Inherit p) }

do_sep:
    | T_SEMICOLON eols {}
    | T_COLON eols {}
    | some_eols {}
    | eols K_DO eols {}

brace_codeblock:
  | T_LBRACE_ARG<pos> eols code_block_body<b> T_RBRACE
      { let args,body = b in CodeBlock(true,args,body,pos) }

do_codeblock:
  | K_DO<pos> eols code_block_body<b> K_lEND
      { let args,body = b in CodeBlock(false,args,body,pos) }
      
code_block:
  | brace_codeblock<cb> {cb}
  | do_codeblock<cb> {cb}

code_block_body:
    /* for when the lexer sees "||" instead of two "|"'s */
  | T_OROP eols stmt_list<body> {(Some [],body)}
  | T_VBAR formal_arg_list<args> T_VBAR eols stmt_list<body>
      {(Some args,body)}
  | stmt_list<body>
    {(None, body)}

formal_arg:
  | identifier<id> { seen dyp id; Formal_id id }
  | T_UAMPER T_LID<id,pos> { seen_str dyp id; Formal_amp id }
  | T_AMPER T_LID<id,pos> { seen_str dyp id; Formal_amp id }
  | T_USTAR T_LID<id,pos>  { seen_str dyp id; Formal_star id}
  | T_USTAR {Formal_rest}
  | T_LID<id,pos> T_ASSIGN eols arg<e> { seen_str dyp id; Formal_default (id,e) }
  | lparen formal_arg_nonempty_list<f> T_RPAREN { Formal_tuple f }

formal_arg_nonempty_list:
  | formal_arg<f> { [f] }
  | formal_arg<f> T_COMMA { [f;Formal_rest] }
  | formal_arg<f> T_COMMA eols formal_arg_nonempty_list<fs> 
      @{ f::fs, [Dyp.Dont_shift] }

formal_arg_list:
  | { [] }
  | formal_arg_nonempty_list<l> {l}

method_formals:
  | eol_or_semi { [] }
  | formal_arg_nonempty_list<formals> eol_or_semi
      {match formals with
      (Formal_tuple _)::_ -> raise Dyp.Giveup
    | e -> e
      }
  | lparen eols formal_arg_list<formals> eols T_RPAREN {
      (* RPAREN usually puts the lexer in an end state, but we need to
         force it to an end state *)
      state_override := true; formals}

lhs:
  | scoped_id<id> { id }
  | primary<p> T_LBRACK_ARG<pos> eols arg_comma_star_list<args> eols T_RBRACK
      { methodcall (Binop(p,Op_DOT,Operator(Op_AREF,pos),H.pos_of p)) args None (H.pos_of p)}
  | primary<p> T_DOT eols message_identifier<m>
      { methodcall (Binop(p,Op_DOT,m,H.pos_of p)) [] None (H.pos_of p)}

mlhs:
  | mlhs_clean<ls> {ls}
  | mlhs_clean<ls> T_COMMA<pos> { ls @ [UOperator(Op_UStar,pos)] }

mlhs_clean:
  | T_LPAREN eols mlhs<l> eols T_RPAREN { [(tuple l)] }
  | mlhs_item<l> { [l] }
  | mlhs_item<l> T_COMMA eols mlhs_rest<ls> { l::ls}
  | T_USTAR<pos> lhs<l> { [Unary(Op_UStar,l,pos)] }

mlhs_rest:
  | mlhs_item<l> { [l] }
  | mlhs_item<l> T_COMMA eols mlhs_rest<ls> 
      @{ l::ls, [Dyp.Dont_shift] }
  | T_USTAR<pos> lhs<l> { [Unary(Op_UStar,l,pos)] }

mlhs_item:
  | lhs<l> {l}
  | T_USTAR<pos> { UOperator(Op_UStar,pos) } 
  | T_LPAREN eols mlhs<ls> eols T_RPAREN { tuple ls }

command_codeblock:
  | command<c> { c }
  | command_name<c> code_block<cb> { command_codeblock c cb }

mrhs:
  | arg_comma_star_list<args>
      { match args with [] -> raise Dyp.Giveup | _ -> args}
  | topcall<c> { [c] }
  | T_LBRACK<pos> eols call_args<r> eols T_RBRACK { [Array(r,pos)] }
  | T_USTAR<pos> arg<a> { [Unary(Op_UStar,a,pos)] }
  | T_USTAR<pos> command_codeblock<c> { [Unary(Op_UStar,c,pos)] }

  | T_USTAR<pos1> T_LBRACK<pos2> eols call_args<r> eols T_RBRACK
      { [Unary(Op_UStar,Array(r,pos2),pos1)] }

then_sep:
    | T_SEMICOLON eols {}
    | T_COLON eols {}
    | some_eols {}
    | eols K_THEN eols {}

when_clauses:
  | { [] }
  | K_WHEN arg_comma_star_list<e> then_sep stmt_list<es> when_clauses<rest>
    { (e,es) :: rest }

body_exn:
 | stmt_list<body> rescue_list<resc_e> 
     case_else<else_e> ensure_clause<ens_e>
     { {body_exprs = body;
    rescue_exprs = resc_e;
    ensure_expr = ens_e;
    else_expr = else_e} }

rescue_clause:
  | K_RESCUE<resc_pos> then_sep stmt_list<body>
      { let pos = match body with
      | [] -> resc_pos 
      | hd::_ -> H.pos_of hd
    in (S Empty,mk_block body pos) }

  | K_RESCUE<pos> T_ASSOC seen_id<bind> then_sep stmt_list<body>
      { (Binop(S Empty,Op_ASSOC,bind,pos), mk_block body pos) }

  | K_RESCUE<pos> arg_comma_star_list<exn> then_sep stmt_list<body>
    { (tuple exn,mk_block body pos) }

  | K_RESCUE<pos> arg_comma_star_list<exn> 
    { (tuple exn,S Empty) }


rescue_list_rest:
  | { [] }
  | rescue_clause<r> rescue_list_rest<rs> { r::rs }

rescue_list:
  | { [] }
    /* need to force an eol/semi here to disambiguate the rescue modifier */
  | eol_or_semi rescue_clause<r> rescue_list<rs> /*_rest*/
      { r::rs }

case_else:
  | { [] }
  | K_ELSE eols stmt_list<ss> { ss }

ensure_clause:
  | { [] }
  | K_ENSURE eols stmt_list<body> { body }

if_else_clauses:
  | { [] }
  | K_ELSE eols stmt_list<body>
    { body }
  | K_ELSIF<pos> eols expr<guard> then_sep stmt_list<body> if_else_clauses<rest>
    { [S (If( guard, body, rest, pos)) ] }

meth_or_atom:
    | method_name<e>  {e}
    | T_ATOM<a,pos> { Literal((Atom a),pos) }

meth_or_atom_list:
    | meth_or_atom<e> { [e] }
    | meth_or_atom<e> T_COMMA meth_or_atom_list<lst>{ e::lst }

method_name:
  | message_identifier<e> { e }
  | method_name<e> T_ASSIGN { add_eq e }
  | method_name<id1> T_DOT eols message_identifier<id2> 
      { Binop(id1,Op_DOT,id2,H.pos_of id1) }
  | method_name<id1> T_DOT eols assignable<id2> T_ASSIGN
      { Binop(id1,Op_DOT,add_eq id2,H.pos_of id1) }

  | T_USCOPE<pos> identifier<id>     { Unary(Op_UScope,id,pos)}
  | T_USCOPE<pos> keyword_as_id<id>  { Unary(Op_UScope,id,pos)}

  | method_name<id1> T_SCOPE identifier<id2>    { scope id1 id2 }
  | method_name<id1> T_SCOPE keyword_as_id<id2> { scope id1 id2 }
  | T_LPAREN<pos> eols stmt_list<ss> T_RPAREN T_DOT message_identifier<m>
      { Binop(mk_block ss (H.pos_of (List.hd ss)), Op_DOT,m, pos) }

assignable:
  | identifier<e>  { e }
  | keyword_as_id<k> { k }
  | T_LBRACK_ARG<pos> T_RBRACK { Operator(Op_AREF,pos) }
  | T_LBRACK<pos> T_RBRACK     { Operator(Op_AREF,pos) }

message_identifier:
  | assignable<e> { e }
  | T_LBRACK_ARG<pos> T_RBRACK T_ASSIGN { Operator(Op_ASET,pos) }
  | bin_op<op> { Operator(op,Lexing.dummy_pos) }
  | T_UPLUS<pos>       { UOperator(Op_UPlus,pos) }
  | T_UMINUS<pos>      { UOperator(Op_UMinus,pos) }
  | T_TILDE<pos>       { UOperator(Op_UTilde,pos) }

bin_op:
  | T_CMP    { Op_CMP } 
  | T_EQ     { Op_EQ }
  | T_SLASH  { Op_DIV }
  | T_PERCENT{ Op_REM }
  | T_EQQ    { Op_EQQ }
  | T_NEQ    { Op_NEQ }
  | T_GEQ    { Op_GEQ }
  | T_LEQ    { Op_LEQ }
  | T_MATCH  { Op_MATCH }
  | T_NMATCH { Op_NMATCH }
  | T_CARROT { Op_XOR }
  | T_POW    { Op_POW }
  | T_VBAR   { Op_BOR }
  | T_ASSOC  { Op_ASSOC }
  | T_AMPER  { Op_BAND }
  | T_PLUS   { Op_PLUS }
  | T_MINUS  { Op_MINUS }
  | T_STAR   { Op_TIMES }
  | T_LSHFT  { Op_LSHIFT }
  | T_RSHFT  { Op_RSHIFT }
  | T_LT     { Op_LT }
  | T_GT     { Op_GT }
  | T_DOT2   { Op_DOT2 }
  | T_DOT3   { Op_DOT3 }

unary_op:
  | T_UPLUS<pos>   { Op_UPlus,pos }
  | T_UMINUS<pos>  { Op_UMinus,pos }
  | T_TILDE<pos>   { Op_UTilde,pos }
  | T_BANG<pos>    { Op_UBang,pos }

keyword_as_id:
  | K_CLASS<t_info,pos>   { Id(ID_Lowercase, "class", pos) }
  | K_MODULE<t_info,pos>  { Id(ID_Lowercase, "module", pos) }
  | K_DEF<t_info,pos>     { Id(ID_Lowercase, "def", pos) }
  | K_END<pos>     { Id(ID_Uppercase, "END", pos) }
  | K_ALIAS<pos>   { Id(ID_Lowercase, "alias", pos) }
  | K_UNDEF<pos>   { Id(ID_Lowercase, "undef", pos) }
  | K_BEGIN<pos>   { Id(ID_Lowercase, "BEGIN", pos) }
  | K_RESCUE<pos>  { Id(ID_Lowercase, "rescue", pos) }
  | K_ENSURE<pos>  { Id(ID_Lowercase, "ensure", pos) }
  | K_IF<pos>      { Id(ID_Lowercase, "if", pos) }
  | K_UNLESS<pos>  { Id(ID_Lowercase, "unless", pos) }
  | K_THEN<pos>    { Id(ID_Lowercase, "then", pos) }
  | K_ELSIF<pos>   { Id(ID_Lowercase, "elsif", pos) }
  | K_ELSE<pos>    { Id(ID_Lowercase, "else", pos) }
  | K_CASE<pos>    { Id(ID_Lowercase, "case", pos) }
  | K_WHEN<pos>    { Id(ID_Lowercase, "when", pos) }
  | K_WHILE<pos>   { Id(ID_Lowercase, "while", pos) }
  | K_UNTIL<pos>   { Id(ID_Lowercase, "until", pos) }
  | K_FOR<pos>     { Id(ID_Lowercase, "for", pos) }
  | K_IN<pos>      { Id(ID_Lowercase, "in", pos) }
  | K_DO<pos>      { Id(ID_Lowercase, "do", pos) }
  | K_RETURN<pos>  { Id(ID_Lowercase, "return", pos) }
  | K_AND<pos>     { Id(ID_Lowercase, "and", pos) }
  | K_OR<pos>      { Id(ID_Lowercase, "or", pos) }
  | K_NOT<pos>     { Id(ID_Lowercase, "not", pos) }
/*  | K_DEFINED<pos> { Id(ID_Lowercase, "defined?", pos) }*/
  | K_lBEGIN<pos>  { Id(ID_Lowercase, "begin", pos) }
  | K_lEND<pos>    { Id(ID_Lowercase, "end", pos) }
  | K_YIELD<pos>   { Id(ID_Lowercase, "yield", pos) }

identifier:
  | T_BUILTIN_VAR<id,pos> { Id(ID_Builtin, id, pos) }
  | T_GLOBAL_VAR<id,pos>  { Id (ID_Global, id, pos) }
  | T_UID<id,pos>  { Id (ID_Uppercase, id, pos)}
  | K_NIL<pos>     { Literal(Nil,pos) }
  | K_SELF<pos>    { Literal(Self,pos) }
  | K_TRUE<pos>    { Literal(True,pos) }
  | K_FALSE<pos>   { Literal(False,pos) }
  | T_LID<id,pos>  { Id (ID_Lowercase, id, pos)}
  | T_INST_VAR<id,pos>    { Id(ID_Instance, id, pos) }
  | T_CLASS_VAR<id,pos>    { Id(ID_Class, id, pos) }

one_string:
  | T_SINGLE_STRING<s,pos> { Literal( String(Single s), pos) }
  | T_DOUBLE_BEG<pos> interp_str<istr> 
      { Literal(String (Double istr),pos) }

  | T_DOUBLE_STRING<s,pos> { Literal( String(Double s), pos) }
  | T_USER_STRING<m,str,pos> { process_user_string m str pos }
  | T_USER_BEG<m,pos> interp_str<str> { process_user_string m str pos }

string:
  | one_string<s> {s} /* ("abc" 'def') is the string "abcdef" */

  | string<s1> one_string<s2> { merge_string_lits s1 s2 }

constant:
  | string<s> { s }

  | T_TICK_BEG<pos> interp_str<istr>
      { Literal (String (Tick istr),pos) }

  | T_ATOM_BEG<pos> interp_str<istr> 
      { Literal (Atom istr,pos) }

  | T_REGEXP_BEG<pos> interp_str<istr> T_REGEXP_MOD<mods>
      { Literal(Regexp (istr,mods),pos) }
  | T_REGEXP<s,m,pos> { Literal(Regexp (s,m),pos) }

  | T_FIXNUM<i,pos> { Literal(FixNum i,pos) }
  | T_BIGNUM<i,pos> { Literal(BigNum i,pos) }
  | T_FLOAT<s,f,pos> { Literal((Float(s,f)),pos) }
  | T_ATOM<a,pos> { Literal (Atom a,pos) }

interp_str:
  | T_SINGLE_STRING<str,p> {[StrChars str]}
  | interp_str_work<i> 
      {match i with [] -> [StrChars ""] | lst -> lst}

interp_str_work:
  | T_INTERP_STR<s,pos> interp_code<tl>
      { if s = "" then tl else (StrChars s)::tl }

  | T_INTERP_END<s,pos2> 
      { if s = "" then [] else [StrChars s] }

interp_code:
  | eols stmt_list<ss> interp_str_work<tl>
      { match ss with
          | [] -> tl
          | x::_ -> StrExpr (mk_block ss (H.pos_of x))::tl }

  | T_INTERP_END<s,pos> 
      { if s = "" then [] else [StrChars s] }

lparen:
  | T_LPAREN<pos> {pos}
  | T_LPAREN_ARG<pos> {pos}

/*(*************************************************************************)*/
/*(*1 Misc *)*/
/*(*************************************************************************)*/

eol_or_semi:
 | T_SEMICOLON {}
 | T_EOL {}

some_eols :
  | T_EOL eols {}
